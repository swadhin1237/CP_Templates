{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Print to console": {
		"scope": "cpp",
		"prefix": "mod_int",
		"body": [			 
 
"using uint = unsigned int;using ll = long long;using ull = unsigned long long;",
"ll myRand(ll B) {",
"\treturn (ull)rng() % B;",
"}",
" const uint MOD = 1000000007;",
"template<uint mod = MOD> struct mint { // 1000000007  1000000009",
"\tuint x;",
" ",
"\tmint() : x(0) {}",
"\tmint(ll _x) {",
"\t\t_x %= mod;",
"\t\tif (_x < 0) _x += mod;",
"\t\tx = _x;",
"\t}",
" ",
"\tmint& operator += (const mint &a) {",
"\t\tx += a.x;",
"\t\tif (x >= mod) x -= mod;",
"\t\treturn *this;",
"\t}",
"\tmint& operator -= (const mint &a) {",
"\t\tx += mod - a.x;",
"\t\tif (x >= mod) x -= mod;",
"\t\treturn *this;",
"\t}",
"\tmint& operator *= (const mint &a) {",
"\t\tx = (ull)x * a.x % mod;",
"\t\treturn *this;",
"\t}",
"\tmint pow(ll pw) const {",
"\t\tmint res = 1;",
"\t\tmint cur = *this;",
"\t\twhile(pw) {",
"\t\t\tif (pw & 1) res *= cur;",
"\t\t\tcur *= cur;",
"\t\t\tpw >>= 1;",
"\t\t}",
"\t\treturn res;",
"\t}",
"\tmint inv() const {",
"\t\tassert(x != 0);",
"\t\tuint t = x;",
"\t\tuint res = 1;",
"\t\twhile(t != 1) {",
"\t\t\tuint z = mod / t;",
"\t\t\tres = (ull)res * (mod - z) % mod;",
"\t\t\tt = mod - t * z;",
"\t\t}",
"\t\treturn res;",
"\t}",
"\tmint& operator /= (const mint &a) {",
"\t\treturn *this *= a.inv();",
"\t}",
"\tmint operator + (const mint &a) const {",
"\t\treturn mint(*this) += a;",
"\t}",
"\tmint operator - (const mint &a) const {",
"\t\treturn mint(*this) -= a;",
"\t}",
"\tmint operator * (const mint &a) const {",
"\t\treturn mint(*this) *= a;",
"\t}",
"\tmint operator / (const mint &a) const {",
"\t\treturn mint(*this) /= a;",
"\t}",
" ",
"\tbool sqrt(mint &res) const {",
"\t\tif (mod == 2 || x == 0) {",
"\t\t\tres = *this;",
"\t\t\treturn true;",
"\t\t}",
"\t\tif (pow((mod - 1) / 2) != 1) return false;",
"\t\tif (mod % 4 == 3) {",
"\t\t\tres = pow((mod + 1) / 4);",
"\t\t\treturn true;",
"\t\t}",
"\t\tint pw = (mod - 1) / 2;",
"\t\tint K = 30;",
"\t\twhile((1 << K) > pw) K--;",
"\t\twhile(true) {",
"\t\t\tmint t = myRand(mod);",
"\t\t\tmint a = 0, b = 0, c = 1;",
"\t\t\tfor (int k = K; k >= 0; k--) {",
"\t\t\t\ta = b * b;",
"\t\t\t\tb = b * c * 2;",
"\t\t\t\tc = c * c + a * *this;",
"\t\t\t\tif (((pw >> k) & 1) == 0) continue;",
"\t\t\t\ta = b;",
"\t\t\t\tb = b * t + c;",
"\t\t\t\tc = c * t + a * *this;",
"\t\t\t}",
"\t\t\tif (b == 0) continue;",
"\t\t\tc -= 1;",
"\t\t\tc *= mint() - b.inv();",
"\t\t\tif (c * c == *this) {",
"\t\t\t\tres = c;",
"\t\t\t\treturn true;",
"\t\t\t}",
"\t\t}",
"\t\tassert(false);",
"\t}",
" ",
"\tbool operator == (const mint &a) const {",
"\t\treturn x == a.x;",
"\t}",
"\tbool operator != (const mint &a) const {",
"\t\treturn x != a.x;",
"\t}",
"\tbool operator < (const mint &a) const {",
"\t\treturn x < a.x;",
"\t}",
"};",
"template<uint mod = MOD> struct Factorials {",
"\tusing Mint = mint<mod>;",
"\tvector<Mint> f, fi;",
" ",
"\tFactorials() : f(), fi() {}",
"\tFactorials(int n) {",
"\t\tn += 10;",
"\t\tf = vector<Mint>(n);",
"\t\tfi = vector<Mint>(n);",
"\t\tf[0] = 1;",
"\t\tfor (int i = 1; i < n; i++)",
"\t\t\tf[i] = f[i - 1] * i;",
"\t\tfi[n - 1] = f[n - 1].inv();",
"\t\tfor (int i = n - 1; i > 0; i--)",
"\t\t\tfi[i - 1] = fi[i] * i;",
"\t}",
" ",
"\tMint C(int n, int k) {",
"\t\tif (k < 0 || k > n) return 0;",
"\t\treturn f[n] * fi[k] * fi[n - k];",
"\t}",
"};",
"template<uint mod = MOD> struct Powers {",
"\tusing Mint = mint<mod>;",
"\tvector<Mint> p, pi;",
" ",
"\tPowers() : p(), pi() {}",
"\tPowers(int n, Mint x) {",
"\t\tn += 10;",
"\t\tif (x == 0) {",
"\t\t\tp = vector<Mint>(n);",
"\t\t\tp[0] = 1;",
"\t\t} else {",
"\t\t\tp = vector<Mint>(n);",
"\t\t\tpi = vector<Mint>(n);",
"\t\t\tp[0] = pi[0] = 1;",
"\t\t\tMint xi = x.inv();",
"\t\t\tfor (int i = 1; i < n; i++) {",
"\t\t\t\tp[i] = p[i - 1] * x;",
"\t\t\t\tpi[i] = pi[i - 1] * xi;",
"\t\t\t}",
"\t\t}",
"\t}",
" ",
"\tMint pow(int n) {",
"\t\tif (n >= 0)",
"\t\t\treturn p[n];",
"\t\telse",
"\t\t\treturn pi[-n];",
"\t}",
"};",
"template<uint mod = MOD> struct Inverses {",
"\tusing Mint = mint<mod>;",
"\tvector<Mint> ii;",
" ",
"\tInverses() : ii() {}",
"\tInverses(int n) {",
"\t\tn += 10;",
"\t\tii = vector<Mint>(n);",
"\t\tii[1] = 1;",
"\t\tfor (int x = 2; x < n; x++)",
"\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);",
"\t}",
" ",
"\tMint inv(Mint x) {",
"\t\tassert(x != 0);",
"\t\tuint t = x.x;",
"\t\tuint res = 1;",
"\t\twhile(t >= (int)ii.size()) {",
"\t\t\tuint z = mod / t;",
"\t\t\tres = (ull)res * (mod - z) % mod;",
"\t\t\tt = mod - t * z;",
"\t\t}",
"\t\treturn ii[t] * res;",
"\t}",
"};",
"using Mint = mint<>;",
		 
		],
		"description": "Log output to console"
	}
}