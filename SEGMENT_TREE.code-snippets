{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Print to console": {
		"scope": "cpp",
		"prefix": "segment_tree",
		"body": [
"class segment_tree",
"{",
"public:",
"\tvi arr, tree, lazy;",
"\tsegment_tree(vi arrey)",
"\t{",
"\t\tarr = arrey; int n = sz(arr);",
"\t\ttree.resize(5*n);",
"\t\tlazy.resize(5*n);",
"\t}",
"\tint merge(int a , int b ){",
"\t\treturn max(a,b);",
"\t}",
"\tvoid build_tree(int node, int a, int b)",
"\t{",
"\t\tif (a > b)",
"\t\t\treturn;",
"\t\tif (a == b)",
"\t\t{",
"\t\t\ttree[node] = arr[a];",
"\t\t\treturn;",
"\t\t}",
"\t\tbuild_tree(node * 2, a, (a + b) / 2);                 // Init left child",
"\t\tbuild_tree(node * 2 + 1, 1 + (a + b) / 2, b);         // Init right child",
"\t\ttree[node] = merge(tree[node * 2], tree[node * 2 + 1]); // Init root value",
"\t}",
"",
"\tvoid lazypropagate(int node, int a, int b)",
"\t{",
"\t\tif (lazy[node] != 0)",
"\t\t{",
"\t\t\ttree[node] += lazy[node];",
"\t\t\tif (a != b)",
"\t\t\t{",
"\t\t\t\tlazy[node * 2] += lazy[node];",
"\t\t\t\tlazy[node * 2 + 1] += lazy[node];",
"\t\t\t}",
"",
"\t\t\tlazy[node] = 0; // Reset it",
"\t\t}",
"\t}",
"\t/**",
"\t * Increment elements within range [i, j] with value value",
"\t */",
"\tvoid update_tree(int node, int a, int b, int i, int j, int value)",
"\t{",
"\t\tlazypropagate(node, a, b);",
"\t\tif (a > b || a > j || b < i)",
"\t\t\treturn;",
"",
"\t\tif (i <= a && b <= j)",
"\t\t{",
"\t\t\ttree[node] += value;",
"\t\t\tif (a != b)",
"\t\t\t{",
"\t\t\t\tlazy[node * 2] += value;",
"\t\t\t\tlazy[node * 2 + 1] += value;",
"\t\t\t}",
"",
"\t\t\treturn;",
"\t\t}",
"\t\tint mid = (a + b) / 2;",
"\t\tupdate_tree(node * 2, a, mid, i, j, value);         // Updating left child",
"\t\tupdate_tree(1 + node * 2, 1 + mid, b, i, j, value); // Updating right child",
"\t\ttree[node] = merge(tree[node * 2], tree[node * 2 + 1]); // Init root value",
"\t}",
"",
"\t/**",
"\t * Query tree to get max element value within range [i, j]",
"\t */",
"\tint query_tree(int node, int a, int b, int i, int j)",
"\t{",
"",
"\t\tif (a > b || a > j || b < i)",
"\t\t\treturn -inf;",
"\t\tlazypropagate(node, a, b);",
"",
"\t\tif (i <= a && b <= j)",
"\t\t\treturn tree[node];",
"\t\tint mid = (a + b) / 2;",
"\t\tint q1 = query_tree(node * 2, a, mid, i, j);         // Query left child",
"\t\tint q2 = query_tree(1 + node * 2, 1 + mid, b, i, j); // Query right child",
"\t\tint res = merge(q1, q2);                               // Return final result",
"\t\treturn res;",
"\t}",
"};\t\t",
		],
		"description": "Log output to console"
	}
}