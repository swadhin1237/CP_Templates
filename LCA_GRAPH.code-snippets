{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Print to console": {
		"scope": "cpp",
		"prefix": "lca_graph",
		"body": [
"\tvvi up(n, vi(20));",
"",
"\tauto binary_lifting = [&](auto self, int src, int par) -> void",
"\t{",
"\t\tup[src][0] = par;",
"\t\tfor (int i = 1; i < 20; i++)",
"\t\t{",
"\t\t\tif (up[src][i - 1] != -1)",
"\t\t\t\tup[src][i] = up[up[src][i - 1]][i - 1];",
"\t\t\telse",
"\t\t\t\tup[src][i] = -1;",
"\t\t}",
"\t\tfor (auto it : node[src])",
"\t\t{",
"\t\t\tif (it != par)",
"\t\t\t{",
"\t\t\t\tself(self, it, src);",
"\t\t\t}",
"\t\t}",
"\t\treturn;",
"\t};",
"\tbinary_lifting(binary_lifting, 0, -1);",
"\t",
"\tauto lift_node=[&](int node, int jump_required)->int",
"\t{",
"",
"\t\tfor (int i = 19; i >= 0; i--)",
"\t\t{",
"\t\t\tif (node == -1 || jump_required == 0)",
"\t\t\t\treturn node;",
"",
"\t\t\tif (jump_required >= (1 << i))",
"\t\t\t{",
"\t\t\t\tjump_required-=(1 << i);",
"\t\t\t\tnode = up[node][i];",
"\t\t\t}",
"\t\t}",
"\t\treturn node;",
"\t};",
"",
"\tauto lca = [&](int a, int b)",
"\t{",
"\t\tif (depth[a] < depth[b])",
"\t\t\tswap(a, b);",
"",
"\t\ta = lift_node(a,depth[a]-depth[b]);",
"",
"\t\tif (a == b)",
"\t\t\treturn a;",
"",
"\t\tfor (int j = 19; j >= 0; j--)",
"\t\t{",
"\t\t\tif (up[a][j] != up[b][j])",
"\t\t\t{",
"\t\t\t\ta = up[a][j];",
"\t\t\t\tb = up[b][j];",
"\t\t\t}",
"\t\t}",
"",
"\t\treturn up[a][0];",
"\t};",
		
		],
		"description": "Log output to console"
	}
}